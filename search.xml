<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>R-square</title>
    <url>/2020/11/17/R-square/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SQL_互相关注的对数</title>
    <url>/2020/10/27/Sql-%E4%BA%92%E7%9B%B8%E5%85%B3%E6%B3%A8%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%B9%E6%95%B0/</url>
    <content><![CDATA[<p>表名：user_table</p>
<p>字段：user_id, follower_id</p>
<p>描述：该表统计了每个用户的id，以及其所关注的用户的id，求互相关注的用户的对数。</p>
<a id="more"></a>

<h2 id="（1）sql写法"><a href="#（1）sql写法" class="headerlink" title="（1）sql写法"></a>（1）sql写法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(a.user_id)/<span class="number">2</span> following_pairs</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> t1.user_id,t1.follower_id</span><br><span class="line"><span class="keyword">FROM</span> user_table t1 <span class="keyword">JOIN</span> user_table t2</span><br><span class="line"><span class="keyword">ON</span> t1.user_id = t2.follower_id <span class="keyword">AND</span> t1.follower_id = t2.user_id) a</span><br></pre></td></tr></table></figure>

<h2 id="（2）思路及注意事项"><a href="#（2）思路及注意事项" class="headerlink" title="（2）思路及注意事项"></a>（2）思路及注意事项</h2><ol>
<li>最普适的方法是表联结，无论是给id还是用户名都可以这么做：让表1中的follower充当表2的user，表1中的user充当表2中的follower。这样可以把所有互相关注的user找出来。不过结果是成双对出现的，比如1 2 2 1和2 1 1 2都会被收录，但是他们表达的都是user1和user2互相关注，所以最后的count要除以2。</li>
<li>由于两个表字段完全一样，所以内部的SELECT不要写*，否则会出现字段冲突。要么选择其中2个，要么重新命名。</li>
<li>COUNT(a.*)报错，是否count ( * )是唯一正确用法？</li>
</ol>
<h2 id="（3）举一反三"><a href="#（3）举一反三" class="headerlink" title="（3）举一反三"></a>（3）举一反三</h2>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL-用户向</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-留存率计算</title>
    <url>/2020/10/27/Sql-%E7%94%A8%E6%88%B7%E7%95%99%E5%AD%98%E7%8E%87%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>表名：user_log</p>
<p>字段：device_id, log_time</p>
<p>描述：device_id为用户的设备id（unique），log_time为用户的登陆时间记录</p>
<p><strong>要求：计算某段日期内用户的次日，3日，7日，15日留存率</strong></p>
<a id="more"></a>

<h2 id="（1）sql写法"><a href="#（1）sql写法" class="headerlink" title="（1）sql写法"></a>（1）sql写法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.first_login_date,</span><br><span class="line">       <span class="keyword">CONCAT</span>(<span class="number">100</span>*<span class="keyword">round</span>(t1<span class="number">.2</span>_day_user/t1.first_day_users,<span class="number">4</span>),<span class="string">&quot;%&quot;</span>) rate_2,</span><br><span class="line">       <span class="keyword">CONCAT</span>(<span class="number">100</span>*<span class="keyword">round</span>(t1<span class="number">.3</span>_user/t1.first_day_users,<span class="number">4</span>),<span class="string">&quot;%&quot;</span>) rate_3,</span><br><span class="line">       <span class="keyword">CONCAT</span>(<span class="number">100</span>*<span class="keyword">round</span>(t1<span class="number">.7</span>_user/t1.first_day_users,<span class="number">4</span>),<span class="string">&quot;%&quot;</span>) rate_7,</span><br><span class="line">       <span class="keyword">CONCAT</span>(<span class="number">100</span>*<span class="keyword">round</span>(t1<span class="number">.15</span>_day_user/t1.first_day_users,<span class="number">4</span>),<span class="string">&quot;%&quot;</span>) rate_15,</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> a.first_login_date, </span><br><span class="line">       <span class="keyword">COUNT</span>(<span class="keyword">distinct</span> a.device_id) first_day_users,</span><br><span class="line">       <span class="keyword">COUNT</span>(<span class="keyword">distinct</span> b.device_id) <span class="number">2</span>_day_users,</span><br><span class="line">       <span class="keyword">COUNT</span>(<span class="keyword">distinct</span> c.device_id) <span class="number">3</span>_day_users,</span><br><span class="line">       <span class="keyword">COUNT</span>(<span class="keyword">distinct</span> d.device_id) <span class="number">7</span>_day_users,</span><br><span class="line">       <span class="keyword">COUNT</span>(<span class="keyword">distinct</span> e.device_id) <span class="number">15</span>_day_users</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> device_id, <span class="keyword">min</span>(log_time) first_login_date</span><br><span class="line"><span class="keyword">FROM</span> user_log</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> device_id) a </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">user_log b <span class="keyword">ON</span> a.device_id = b.device_id <span class="keyword">AND</span> DATADIFF(b.log_time, a.first_login_date)=<span class="number">1</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">user_log c <span class="keyword">ON</span> a.device_id = c.device_id <span class="keyword">AND</span> DATADIFF(c.log_time, a.first_login_date)=<span class="number">2</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">user_log d <span class="keyword">ON</span> a.device_id = d.device_id <span class="keyword">AND</span> DATADIFF(d.log_time, a.first_login_date)=<span class="number">6</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">user_log e <span class="keyword">ON</span> a.device_id = e.device_id <span class="keyword">AND</span> DATADIFF(e.log_time, a.first_login_date)=<span class="number">14</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.first_login_date) t1</span><br></pre></td></tr></table></figure>

<h2 id="（2）思路及注意事项"><a href="#（2）思路及注意事项" class="headerlink" title="（2）思路及注意事项"></a>（2）思路及注意事项</h2><ol>
<li>首先要求出每个用户第一次登录的时间，并以此表作为基础，左联其他表格。</li>
<li>求留存时按照first_login_date分组，可以求得不同天的登录用户数。</li>
<li>常用函数DATEDIFF, ROUND, CONCAT的用法</li>
</ol>
<h2 id="（3）举一反三"><a href="#（3）举一反三" class="headerlink" title="（3）举一反三"></a>（3）举一反三</h2>]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL-用户向</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL经典50题(1-6)</title>
    <url>/2020/11/16/Sql-%E7%BB%8F%E5%85%B850%E9%A2%98(1-6)/</url>
    <content><![CDATA[<p>SQL经典50题，在网上比较有名，B站的链接是<a href="https://www.bilibili.com/video/BV1q4411G7Lw?p=9">https://www.bilibili.com/video/BV1q4411G7Lw?p=9</a> </p>
<p>4个表格基于学生，成绩，课程，教师，与真正面试时及实际工作中的业务场景还有一定差距。比较适合面试前练手以及熟悉SQL中比较基础的操作，比如表联结、子查询等。</p>
<p>在这个系列中，我尽量把每道题能想到的思路都进行实现，同时部分题目进行了一定拓展。</p>
<a id="more"></a>

<h4 id="1-查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号（重点）"><a href="#1-查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号（重点）" class="headerlink" title="1.查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号（重点）"></a>1.查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号（重点）</h4><h5 id="思路1，自联结"><a href="#思路1，自联结" class="headerlink" title="思路1，自联结"></a>思路1，自联结</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> s1.s_id</span><br><span class="line"><span class="keyword">from</span> score s1, score s2</span><br><span class="line"><span class="keyword">WHERE</span> s1.c_id = <span class="string">&#x27;01&#x27;</span> <span class="keyword">AND</span> s2.c_id = <span class="string">&#x27;02&#x27;</span> <span class="keyword">AND</span> s1.s_id = s2.s_id <span class="keyword">AND</span> s1.s_score &gt; s2.s_score;</span><br></pre></td></tr></table></figure>

<h5 id="思路2，直观思路–稍微拓展-显示学生姓名"><a href="#思路2，直观思路–稍微拓展-显示学生姓名" class="headerlink" title="思路2，直观思路–稍微拓展: 显示学生姓名"></a>思路2，直观思路–稍微拓展: 显示学生姓名</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> s1.s_id <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">       s3.s_name <span class="string">&#x27;姓名&#x27;</span>, </span><br><span class="line">       s1.s_score <span class="string">&#x27;01&#x27;</span>, </span><br><span class="line">       s2.s_score <span class="string">&#x27;02&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">Select</span> s_id, s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = <span class="string">&#x27;01&#x27;</span>) s1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">Select</span> s_id, s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id = <span class="string">&#x27;02&#x27;</span>) s2</span><br><span class="line"><span class="keyword">ON</span> s1.s_id = s2.s_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">student s3 <span class="keyword">ON</span> s2.s_id = s3.s_id </span><br><span class="line"><span class="keyword">WHERE</span> s1.s_score &gt; s2.s_score;</span><br></pre></td></tr></table></figure>

<h5 id="拓展，如果有缺考的课记为0分-其余条件不变"><a href="#拓展，如果有缺考的课记为0分-其余条件不变" class="headerlink" title="拓展，如果有缺考的课记为0分,其余条件不变"></a>拓展，如果有缺考的课记为0分,其余条件不变</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> s1.s_id <span class="string">&#x27;student_no.&#x27;</span>, </span><br><span class="line">       <span class="keyword">IFNULL</span>(s1.s_score,<span class="number">0</span>) <span class="string">&#x27;01&#x27;</span>,</span><br><span class="line">       <span class="keyword">IFNULL</span>(s2.s_score,<span class="number">0</span>) <span class="string">&#x27;02&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score s1, score s2</span><br><span class="line"><span class="keyword">WHERE</span> s1.c_id = <span class="string">&#x27;01&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> s2.c_id = <span class="string">&#x27;02&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> s1.s_id = s2.s_id </span><br><span class="line"><span class="keyword">and</span> (<span class="keyword">IFNULL</span>(s1.s_score,<span class="number">0</span>) &gt; <span class="keyword">IFNULL</span>(s2.s_score,<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h4 id="2、查询平均成绩大于60分的学生的学号和平均成绩"><a href="#2、查询平均成绩大于60分的学生的学号和平均成绩" class="headerlink" title="2、查询平均成绩大于60分的学生的学号和平均成绩"></a>2、查询平均成绩大于60分的学生的学号和平均成绩</h4><h5 id="思路，group-by"><a href="#思路，group-by" class="headerlink" title="思路，group by"></a>思路，group by</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意，使用group by的时候，尽量不要把其他字段搞到select里，否则那列只会显示每个组里的第一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> s_id, <span class="keyword">avg</span>(<span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>)) </span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">avg</span>(<span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>))&gt;<span class="number">60</span>;  </span><br><span class="line"><span class="comment">-- IFNULL,若第一个值不为NULL则返回第一个值，否则返回第二个值</span></span><br></pre></td></tr></table></figure>

<h4 id="3-查询所有学生的学号、姓名、选课数、总成绩（不重要）"><a href="#3-查询所有学生的学号、姓名、选课数、总成绩（不重要）" class="headerlink" title="3.查询所有学生的学号、姓名、选课数、总成绩（不重要）"></a>3.查询所有学生的学号、姓名、选课数、总成绩（不重要）</h4><h5 id="思路，group-by-表联结"><a href="#思路，group-by-表联结" class="headerlink" title="思路，group by + 表联结"></a>思路，group by + 表联结</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> s1.s_id,</span><br><span class="line">       s1.s_name, </span><br><span class="line">       <span class="keyword">IFNULL</span>(s2.number_of_class,<span class="number">0</span>),</span><br><span class="line">       <span class="keyword">IFNULL</span>(s2.scores,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">student s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">(<span class="keyword">Select</span> s_id, </span><br><span class="line">        <span class="keyword">count</span>(<span class="keyword">distinct</span> c_id) <span class="string">&#x27;number_of_class&#x27;</span>,</span><br><span class="line">        <span class="keyword">sum</span>(s_score) <span class="string">&#x27;scores&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) s2 </span><br><span class="line"><span class="keyword">ON</span> s1.s_id = s2.s_id;</span><br></pre></td></tr></table></figure>

<h4 id="4-查询姓“猴”的老师的个数（不重要）"><a href="#4-查询姓“猴”的老师的个数（不重要）" class="headerlink" title="4.查询姓“猴”的老师的个数（不重要）"></a>4.查询姓“猴”的老师的个数（不重要）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> t_name)</span><br><span class="line"><span class="keyword">FROM</span> teacher</span><br><span class="line"><span class="keyword">WHERE</span> t_name <span class="keyword">like</span> <span class="string">&quot;猴%&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-查询没学过“张三”老师课的学生的学号、姓名（重点）"><a href="#5-查询没学过“张三”老师课的学生的学号、姓名（重点）" class="headerlink" title="5.查询没学过“张三”老师课的学生的学号、姓名（重点）"></a>5.查询没学过“张三”老师课的学生的学号、姓名（重点）</h4><h5 id="思路，先找到张三老师教什么课-然后对所有学生：只要学过的课in张三老师的课，case-when-1-最后统计结果为0的人"><a href="#思路，先找到张三老师教什么课-然后对所有学生：只要学过的课in张三老师的课，case-when-1-最后统计结果为0的人" class="headerlink" title="思路，先找到张三老师教什么课, 然后对所有学生：只要学过的课in张三老师的课，case when=1,最后统计结果为0的人"></a>思路，先找到张三老师教什么课, 然后对所有学生：只要学过的课in张三老师的课，case when=1,最后统计结果为0的人</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> temp.s_id, </span><br><span class="line">       temp.s_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> s2.s_id, </span><br><span class="line">        s2.s_name, </span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> c_id <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">SELECT</span> c.c_id</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">Select</span> t_id</span><br><span class="line"><span class="keyword">FROM</span> teacher</span><br><span class="line"><span class="keyword">WHERE</span> t_name = <span class="string">&#x27;张三&#x27;</span>) t1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c </span><br><span class="line"><span class="keyword">ON</span> t1.t_id = c.t_id) <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">&#x27;flag&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score s1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> student s2 </span><br><span class="line"><span class="keyword">ON</span> s1.s_id = s2.s_id) temp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> temp.s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(temp.flag)=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="思路2，-找到学过张三老师课的同学，排除即为没学过的"><a href="#思路2，-找到学过张三老师课的同学，排除即为没学过的" class="headerlink" title="思路2， 找到学过张三老师课的同学，排除即为没学过的"></a>思路2， 找到学过张三老师课的同学，排除即为没学过的</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_id, s_name</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_id <span class="keyword">not</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> c_id <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> c_id</span><br><span class="line"><span class="keyword">FROM</span> course c</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> teacher t</span><br><span class="line"><span class="keyword">WHERE</span> t_name = <span class="string">&#x27;张三&#x27;</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="思路3，全联结后找到上张三课的人，再反选"><a href="#思路3，全联结后找到上张三课的人，再反选" class="headerlink" title="思路3，全联结后找到上张三课的人，再反选"></a>思路3，全联结后找到上张三课的人，再反选</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_id, s_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> s_id <span class="keyword">not</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> s1.s_id</span><br><span class="line"><span class="keyword">FROM</span> student s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score s2 <span class="keyword">ON</span> s1.s_id = s2.s_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> s2.c_id = c.c_id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> teacher t <span class="keyword">on</span> c.t_id = t.t_id</span><br><span class="line"><span class="keyword">WHERE</span> t.t_name = <span class="string">&#x27;张三&#x27;</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="6-查询学过“张三”老师所教的所有课的同学的学号、姓名（重点）"><a href="#6-查询学过“张三”老师所教的所有课的同学的学号、姓名（重点）" class="headerlink" title="6.查询学过“张三”老师所教的所有课的同学的学号、姓名（重点）"></a>6.查询学过“张三”老师所教的所有课的同学的学号、姓名（重点）</h4><h5 id="模仿上题思路1，上过一种课flag-1"><a href="#模仿上题思路1，上过一种课flag-1" class="headerlink" title="模仿上题思路1，上过一种课flag+1"></a>模仿上题思路1，上过一种课flag+1</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 本题需要考虑一个老师上多门课的情况</span></span><br><span class="line"><span class="keyword">SELECT</span> s_id, <span class="keyword">sum</span>(flag)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">case</span> <span class="keyword">when</span> c_id <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">SELECT</span> c.c_id</span><br><span class="line"> <span class="keyword">FROM</span> teacher t <span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c </span><br><span class="line"> <span class="keyword">ON</span> c.t_id = t.t_id <span class="keyword">AND</span> t.t_name = <span class="string">&#x27;张三&#x27;</span>) <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> <span class="string">&#x27;flag&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score) temp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> temp.s_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">sum</span>(flag)= (<span class="keyword">SELECT</span> <span class="keyword">count</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> teacher t <span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> c.t_id = t.t_id <span class="keyword">AND</span> t.t_name = <span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="思路2，找出上过张三的课的人，按s-id分组，谁上的课的数量-张三教的课的数量，谁就入选。"><a href="#思路2，找出上过张三的课的人，按s-id分组，谁上的课的数量-张三教的课的数量，谁就入选。" class="headerlink" title="思路2，找出上过张三的课的人，按s_id分组，谁上的课的数量=张三教的课的数量，谁就入选。"></a>思路2，找出上过张三的课的人，按s_id分组，谁上的课的数量=张三教的课的数量，谁就入选。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.s_id, s1.s_name</span><br><span class="line"><span class="keyword">FROM</span> student s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score s2 <span class="keyword">ON</span> s1.s_id = s2.s_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> s2.c_id = c.c_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">join</span> teacher t <span class="keyword">ON</span> c.t_id = t.t_id</span><br><span class="line"><span class="keyword">WHERE</span> t.t_name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s1.s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> s2.c_id) = (<span class="keyword">SELECT</span> <span class="keyword">count</span>(*)</span><br><span class="line">                                  <span class="keyword">FROM</span> teacher t <span class="keyword">INNER</span> <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> c.t_id = t.t_id <span class="keyword">AND</span> t.t_name = <span class="string">&#x27;张三&#x27;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SQL</category>
        <category>SQL经典50题</category>
      </categories>
      <tags>
        <tag>SQL-练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql-经典50题(7-12)</title>
    <url>/2020/11/17/Sql-%E7%BB%8F%E5%85%B850%E9%A2%98(7-12)/</url>
    <content><![CDATA[<p>链接：<a href="https://www.bilibili.com/video/BV1q4411G7Lw?p=9">https://www.bilibili.com/video/BV1q4411G7Lw?p=9</a> </p>
<p>题目汇总：</p>
<ol start="7">
<li>查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名（重点）</li>
<li>查询课程编号为“02”的总成绩（不重点）</li>
<li>查询所有课程成绩小于60分的学生的学号、姓名（这里指的是选哪科哪科不及格，没选课的不算）</li>
<li>查询没有学全所有课的学生的学号、姓名(重点)</li>
<li>查询至少有一科与学号为“01”的学生所学课程相同的学生的学号和姓名（重点）</li>
<li>查询和“01”号同学所学课程完全相同的其他同学的学号(重点)</li>
</ol>
<a id="more"></a>

<h4 id="7-查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名（重点）"><a href="#7-查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名（重点）" class="headerlink" title="7. 查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名（重点）"></a>7. 查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名（重点）</h4><h5 id="思路1，常规思路，把学过01的人和学过02的人取交集"><a href="#思路1，常规思路，把学过01的人和学过02的人取交集" class="headerlink" title="思路1，常规思路，把学过01的人和学过02的人取交集"></a>思路1，常规思路，把学过01的人和学过02的人取交集</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_id, s_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> s_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> a.s_id                         <span class="comment">-- 这句话别忘了，不要只join表不查东西</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> c_id = <span class="string">&#x27;01&#x27;</span>) a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> c_id = <span class="string">&#x27;02&#x27;</span>) b</span><br><span class="line"><span class="keyword">ON</span> a.s_id = b.s_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="思路2，找到学过01的人，在其中找学过02的人"><a href="#思路2，找到学过01的人，在其中找学过02的人" class="headerlink" title="思路2，找到学过01的人，在其中找学过02的人"></a>思路2，找到学过01的人，在其中找学过02的人</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s2.s_id, s2.s_name</span><br><span class="line"><span class="keyword">FROM</span> score s1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> student s2 <span class="keyword">ON</span> s1.s_id = s2.s_id</span><br><span class="line"><span class="keyword">WHERE</span> s2.s_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> c_id = <span class="string">&quot;01&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> s1.c_id = <span class="string">&quot;02&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="思路3，依然case-when"><a href="#思路3，依然case-when" class="headerlink" title="思路3，依然case when"></a>思路3，依然case when</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_id, s_name</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">WHERE</span> s_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> c_id <span class="keyword">IN</span> (<span class="string">&#x27;01&#x27;</span>,<span class="string">&#x27;02&#x27;</span>) <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)=<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="8、查询课程编号为“02”的总成绩（不重点）"><a href="#8、查询课程编号为“02”的总成绩（不重点）" class="headerlink" title="8、查询课程编号为“02”的总成绩（不重点）"></a>8、查询课程编号为“02”的总成绩（不重点）</h4><h5 id="思路1，直接where，没什么难度"><a href="#思路1，直接where，没什么难度" class="headerlink" title="思路1，直接where，没什么难度"></a>思路1，直接where，没什么难度</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c_id, <span class="keyword">sum</span>(<span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>)) <span class="string">&#x27;overall band&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> c_id = <span class="string">&#x27;02&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="思路2，group-by"><a href="#思路2，group-by" class="headerlink" title="思路2，group by"></a>思路2，group by</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c_id, <span class="keyword">SUM</span>(<span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>)) <span class="string">&#x27;overall band&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</span><br><span class="line"><span class="keyword">HAVING</span> c_id=<span class="string">&#x27;02&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="9-查询所有课程成绩小于60分的学生的学号、姓名（这里指的是选哪科哪科不及格，没选课的不算）"><a href="#9-查询所有课程成绩小于60分的学生的学号、姓名（这里指的是选哪科哪科不及格，没选课的不算）" class="headerlink" title="9.查询所有课程成绩小于60分的学生的学号、姓名（这里指的是选哪科哪科不及格，没选课的不算）"></a>9.查询所有课程成绩小于60分的学生的学号、姓名（这里指的是选哪科哪科不及格，没选课的不算）</h4><h5 id="思路，找到至少一种课-gt-60分的人，排除他们即可"><a href="#思路，找到至少一种课-gt-60分的人，排除他们即可" class="headerlink" title="思路，找到至少一种课&gt;=60分的人，排除他们即可"></a>思路，找到至少一种课&gt;=60分的人，排除他们即可</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id, b.s_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">distinct</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_id <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_score&gt;=<span class="number">60</span></span><br><span class="line">))a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student b <span class="keyword">ON</span> a.s_id = b.s_id</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h5 id="思路2，case-when-if-count-不及格的课数等于选的课数"><a href="#思路2，case-when-if-count-不及格的课数等于选的课数" class="headerlink" title="思路2，case when/if/count, 不及格的课数等于选的课数"></a>思路2，case when/if/count, 不及格的课数等于选的课数</h5><h6 id="COUNT-找到小于60分的课和学生，count后为不及格的课数，与自己选过的课比较"><a href="#COUNT-找到小于60分的课和学生，count后为不及格的课数，与自己选过的课比较" class="headerlink" title="COUNT:找到小于60分的课和学生，count后为不及格的课数，与自己选过的课比较"></a>COUNT:找到小于60分的课和学生，count后为不及格的课数，与自己选过的课比较</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.s_id, s.s_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> a.s_id</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">count</span>(c_id) <span class="string">&#x27;cnt1&#x27;</span>             <span class="comment">-- 注意不能count(s_score),因为可能会存在缺考情况，s_score为null</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>)&lt;<span class="number">60</span>                   <span class="comment">-- 这地方的IFNULL要加，如果分数为null则记为0分</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> s_id) a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">count</span>(c_id) <span class="string">&#x27;cnt2&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) b</span><br><span class="line"><span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">AND</span> a.cnt1 = b.cnt2) c <span class="keyword">INNER</span> <span class="keyword">JOIN</span> student s <span class="keyword">ON</span> c.s_id = s.s_id;</span><br></pre></td></tr></table></figure>

<h5 id="IF-原理基本同上"><a href="#IF-原理基本同上" class="headerlink" title="IF: 原理基本同上"></a>IF: 原理基本同上</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id, s.s_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">SUM</span>(<span class="keyword">IF</span>(<span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>)&lt;<span class="number">60</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="string">&#x27;cnt1&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id)a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">count</span>(c_id) <span class="string">&#x27;cnt2&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) b</span><br><span class="line"><span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">AND</span> a.cnt1 = b.cnt2 </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student s <span class="keyword">ON</span> b.s_id = s.s_id;</span><br></pre></td></tr></table></figure>

<h5 id="CASE-WHEN-和IF一毛一样"><a href="#CASE-WHEN-和IF一毛一样" class="headerlink" title="CASE WHEN: 和IF一毛一样"></a>CASE WHEN: 和IF一毛一样</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id, s.s_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>)&lt;<span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="string">&#x27;cnt1&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id)a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">count</span>(c_id) <span class="string">&#x27;cnt2&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) b</span><br><span class="line"><span class="keyword">ON</span> a.s_id = b.s_id <span class="keyword">AND</span> a.cnt1 = b.cnt2 </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student s <span class="keyword">ON</span> b.s_id = s.s_id;</span><br></pre></td></tr></table></figure>

<h5 id="思路3，每个人最高分的课如果都小于60，则必符合条件"><a href="#思路3，每个人最高分的课如果都小于60，则必符合条件" class="headerlink" title="思路3，每个人最高分的课如果都小于60，则必符合条件"></a>思路3，每个人最高分的课如果都小于60，则必符合条件</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_id, s_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> s_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(<span class="keyword">IFNULL</span>(s_score,<span class="number">0</span>))&lt;<span class="number">60</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="10-查询没有学全所有课的学生的学号、姓名-重点"><a href="#10-查询没有学全所有课的学生的学号、姓名-重点" class="headerlink" title="10.查询没有学全所有课的学生的学号、姓名(重点)"></a>10.查询没有学全所有课的学生的学号、姓名(重点)</h4><h5 id="思路1，找到每个学生学了多少节课，是否等于课程总数-再从student里排除"><a href="#思路1，找到每个学生学了多少节课，是否等于课程总数-再从student里排除" class="headerlink" title="思路1，找到每个学生学了多少节课，是否等于课程总数,再从student里排除"></a>思路1，找到每个学生学了多少节课，是否等于课程总数,再从student里排除</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_id, s_name</span><br><span class="line"><span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> s_id <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> c_id) = (<span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> c_id) <span class="keyword">FROM</span> course)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="思路2，直接student作为左表，就能保留所有学生信息，没选课的地方会变成nulll"><a href="#思路2，直接student作为左表，就能保留所有学生信息，没选课的地方会变成nulll" class="headerlink" title="思路2，直接student作为左表，就能保留所有学生信息，没选课的地方会变成nulll"></a>思路2，直接student作为左表，就能保留所有学生信息，没选课的地方会变成nulll</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> st.s_id, st.s_name</span><br><span class="line"><span class="keyword">FROM</span> student st <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.s_id = sc.s_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> st.s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> sc.c_id) &lt; (<span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> c_id) <span class="keyword">FROM</span> course);</span><br></pre></td></tr></table></figure>


<h4 id="11-查询至少有一科与学号为“01”的学生所学课程相同的学生的学号和姓名（重点）"><a href="#11-查询至少有一科与学号为“01”的学生所学课程相同的学生的学号和姓名（重点）" class="headerlink" title="11.查询至少有一科与学号为“01”的学生所学课程相同的学生的学号和姓名（重点）"></a>11.查询至少有一科与学号为“01”的学生所学课程相同的学生的学号和姓名（重点）</h4><h5 id="思路1，先找到01学生学的课，和第5题类似，注意不包含01-s-id-‘01’"><a href="#思路1，先找到01学生学的课，和第5题类似，注意不包含01-s-id-‘01’" class="headerlink" title="思路1，先找到01学生学的课，和第5题类似，注意不包含01(s_id != ‘01’)"></a>思路1，先找到01学生学的课，和第5题类似，注意不包含01(s_id != ‘01’)</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.s_id, a.s_name</span><br><span class="line"><span class="keyword">FROM</span> student a <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">distinct</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score </span><br><span class="line"><span class="keyword">WHERE</span> c_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> c_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_id = <span class="string">&#x27;01&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> s_id != <span class="string">&#x27;01&#x27;</span>) b <span class="keyword">ON</span> a.s_id = b.s_id;</span><br></pre></td></tr></table></figure>

<h5 id="拓展，查找只有两科与学号为“01”的学生所学课程相同的学生的学号和姓名"><a href="#拓展，查找只有两科与学号为“01”的学生所学课程相同的学生的学号和姓名" class="headerlink" title="拓展，查找只有两科与学号为“01”的学生所学课程相同的学生的学号和姓名"></a>拓展，查找只有两科与学号为“01”的学生所学课程相同的学生的学号和姓名</h5><h5 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> st.s_id, st.s_name</span><br><span class="line"><span class="keyword">FROM</span> student st <span class="keyword">INNER</span> <span class="keyword">JOIN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> a.s_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, <span class="keyword">CASE</span> <span class="keyword">WHEN</span> c_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">distinct</span> c_id</span><br><span class="line">                                <span class="keyword">FROM</span> score</span><br><span class="line">                                <span class="keyword">WHERE</span> s_id = <span class="string">&#x27;01&#x27;</span>) <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">&#x27;subjects&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score) a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> a.s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">sum</span>(a.subjects)=<span class="number">2</span>) b <span class="keyword">ON</span> st.s_id = b.s_id;</span><br></pre></td></tr></table></figure>

<h4 id="12-查询和“01”号同学所学课程完全相同的其他同学的学号-重点"><a href="#12-查询和“01”号同学所学课程完全相同的其他同学的学号-重点" class="headerlink" title="12.查询和“01”号同学所学课程完全相同的其他同学的学号(重点)"></a>12.查询和“01”号同学所学课程完全相同的其他同学的学号(重点)</h4><h5 id="思路1，和第6题一样，找出上过01同学课程的人，groupby后数科目"><a href="#思路1，和第6题一样，找出上过01同学课程的人，groupby后数科目" class="headerlink" title="思路1，和第6题一样，找出上过01同学课程的人，groupby后数科目"></a>思路1，和第6题一样，找出上过01同学课程的人，groupby后数科目</h5><h5 id="错误，原因：如果02选择了abcd，01选择了abc，依据下面逻辑，02也会被选出来"><a href="#错误，原因：如果02选择了abcd，01选择了abc，依据下面逻辑，02也会被选出来" class="headerlink" title="错误，原因：如果02选择了abcd，01选择了abc，依据下面逻辑，02也会被选出来"></a>错误，原因：如果02选择了abcd，01选择了abc，依据下面逻辑，02也会被选出来</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> st.s_id, st.s_name</span><br><span class="line"><span class="keyword">FROM</span> student st <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> s_id, c_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> c_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> c_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_id = <span class="string">&#x27;01&#x27;</span></span><br><span class="line">)) a</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.s_id </span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> a.c_id) = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c_id)</span><br><span class="line">                               <span class="keyword">FROM</span> score</span><br><span class="line">                               <span class="keyword">WHERE</span> s_id = <span class="string">&#x27;01&#x27;</span>)</span><br><span class="line">) b <span class="keyword">ON</span> st.s_id = b.s_id;</span><br></pre></td></tr></table></figure>

<h5 id="改进，先筛出和01选课数相同的人，多选的人剔除"><a href="#改进，先筛出和01选课数相同的人，多选的人剔除" class="headerlink" title="改进，先筛出和01选课数相同的人，多选的人剔除"></a>改进，先筛出和01选课数相同的人，多选的人剔除</h5><h5 id="剔除和01选课有不同的人-剩下的人选的课要么和01相同，要么包含于01的课-然后判断数量"><a href="#剔除和01选课有不同的人-剩下的人选的课要么和01相同，要么包含于01的课-然后判断数量" class="headerlink" title="剔除和01选课有不同的人,剩下的人选的课要么和01相同，要么包含于01的课,然后判断数量"></a>剔除和01选课有不同的人,剩下的人选的课要么和01相同，要么包含于01的课,然后判断数量</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  st.s_id, st.s_name</span><br><span class="line"><span class="keyword">FROM</span> student st <span class="keyword">INNER</span> <span class="keyword">JOIN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> s_id,c_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_id <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> s_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> c_id <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> c_id</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">WHERE</span> s_id = <span class="string">&#x27;01&#x27;</span>)</span><br><span class="line">) <span class="keyword">AND</span> s_id != <span class="string">&#x27;01&#x27;</span>) a <span class="keyword">ON</span> st.s_id = a.s_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.s_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> a.c_id)  = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> c_id)</span><br><span class="line">                                  <span class="keyword">FROM</span> score</span><br><span class="line">                                  <span class="keyword">WHERE</span> s_id = <span class="string">&#x27;01&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SQL</category>
        <category>SQL经典50题</category>
      </categories>
      <tags>
        <tag>SQL-练习</tag>
      </tags>
  </entry>
  <entry>
    <title>SKlearn的pipeline机制</title>
    <url>/2020/10/20/sklearn%E7%9A%84pipeline%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>基本上所有评估其和转换器都有三个方法，fit,transform,和fit_transform。而在pipeline中，它的最后一部分为评估器，<strong>也就是说最后一步一定是个分类器</strong>，而前面的预处理、降维、正则化等都是转换器。</p>
<a id="more"></a>

<h2 id="2-pipeline的作用"><a href="#2-pipeline的作用" class="headerlink" title="2.pipeline的作用"></a>2.pipeline的作用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> pipeline</span><br></pre></td></tr></table></figure>

<p>管道机制在机器学习算法中得以应用的根源在于，参数集在新数据集（比如测试集）上的<strong>重复使用</strong>。</p>
<p>管道机制实现了对全部步骤的流式化封装和管理（<strong>streaming workflows with pipelines</strong>）。</p>
<p>当然，这里用的都是包里自带的评估器与分类器，如果想自己写其中的一个过程然后添加到整个pipeline中，还需要继承基类后才能添加进去。</p>
<h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h2><p><strong>1.加载数据集</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://archive.ics.uci.edu/ml/machine-learning-databases/&#x27;</span></span><br><span class="line">                 <span class="string">&#x27;breast-cancer-wisconsin/wdbc.data&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">                                 <span class="comment"># Breast Cancer Wisconsin dataset</span></span><br><span class="line"></span><br><span class="line">X, y = df.values[:, <span class="number">2</span>:], df.values[:, <span class="number">1</span>]</span><br><span class="line">                                <span class="comment"># y为字符型标签</span></span><br><span class="line">                                <span class="comment"># 使用LabelEncoder类将其转换为0开始的数值型</span></span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">y = encoder.fit_transform(y)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.构建pipeline的流程</strong></p>
<p>可放在Pipeline中的步骤可能有：</p>
<ul>
<li>特征标准化是需要的，可作为第一个环节</li>
<li>既然是分类器，classifier也是少不了的，自然是最后一个环节</li>
<li>中间可加上比如数据降维（PCA）</li>
<li>。。。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line">pipe_lr = Pipeline([(<span class="string">&#x27;sc&#x27;</span>, StandardScaler()),</span><br><span class="line">                    (<span class="string">&#x27;pca&#x27;</span>, PCA(n_components=<span class="number">2</span>)),</span><br><span class="line">                    (<span class="string">&#x27;clf&#x27;</span>, LogisticRegression(random_state=<span class="number">1</span>))</span><br><span class="line">                    ])</span><br><span class="line">pipe_lr.fit(X_train, y_train)</span><br><span class="line">print(<span class="string">&#x27;Test accuracy: %.3f&#x27;</span> % pipe_lr.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Test accuracy: 0.947</span></span><br></pre></td></tr></table></figure>

<p>Pipeline对象接受<strong>二元tuple构成的list</strong>，每一个二元 tuple 中的第一个元素为 arbitrary <strong>identifier string</strong>，我们用以获取（access）Pipeline object 中的 individual elements，二元 tuple 中的第二个元素是 scikit-learn与之相适配的<strong>transformer 或者 estimator。</strong></p>
<p><strong>3.Pipeline执行流程的分析</strong></p>
<p>Pipeline 的中间过程由scikit-learn相适配的转换器（transformer）构成，最后一步是一个estimator。比如上述的代码，<em>StandardScaler</em>和<em>PCA</em> <strong>transformer</strong> 构成intermediate steps，LogisticRegression 作为最终的<strong>estimator</strong>。</p>
<p>当我们执行 <code>pipe_lr.fit(X_train, y_train)</code>时，首先由<em>StandardScaler</em>在训练集上执行 <em>fit</em>和<em>transform</em>方法，transformed后的数据又被传递给Pipeline对象的下一步，也即PCA()。和<em>StandardScaler</em>一样，PCA也是执行fit和transform方法，最终将转换后的数据传递给 <em>LosigsticRegression</em>。</p>
<p>参考：<a href="https://blog.csdn.net/lanchunhui/article/details/50521648">https://blog.csdn.net/lanchunhui/article/details/50521648</a></p>
<h3 id="4-fit与transform"><a href="#4-fit与transform" class="headerlink" title="4. fit与transform"></a>4. fit与transform</h3><p>To <a href="https://en.wikipedia.org/wiki/Standard_score">center the data</a> (make it have zero mean and unit standard error), you subtract the mean and then divide the result by the standard deviation:<br>$$<br>x’ = \frac{x-μ}{σ}<br>$$<br>You do that on the training set of data. But then you have to apply the same transformation to your testing set (e.g. in cross-validation), or to newly obtained examples before forecast. But you have to use the exact same two parameters μand σσ(values) that you used for centering the training set.</p>
<p>Hence, every sklearn’s transform’s <code>fit()</code> <strong>just calculates the parameters (e.g. μ and σ in case of <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">StandardScaler</a>) and saves them as an internal object’s state</strong>. Afterwards, you can call its <code>transform()</code> method to <strong>apply the transformation to any particular set of examples</strong>.</p>
<p><code>fit_transform()</code> joins these two steps and is used for the initial fitting of parameters on the training set xx, while also returning the transformed x′x′. Internally, the transformer object just <a href="https://github.com/scikit-learn/scikit-learn/blob/6c3e17989a7d80c34f124365f2c436a3fdcb1497/sklearn/base.py#L659-L690">calls first <code>fit()</code> and then <code>transform()</code></a> on the same data.</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>SKlearn</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>字符与字符串</title>
    <url>/2019/12/26/%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>C语言中字符和字符串的相关知识点。</p>
<a id="more"></a>

<h3 id="1-1字符型与整数型的输入输出"><a href="#1-1字符型与整数型的输入输出" class="headerlink" title="1.1字符型与整数型的输入输出"></a>1.1字符型与整数型的输入输出</h3><p>首先1与’1’在计算机中是不同的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">    c1 = <span class="number">1</span>;</span><br><span class="line">    c2 =<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(c1==c2)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;相同&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可发现他们是不同的，分别以%d的形式输出c1，c2,<br>会得到c1=1,c2=49.<br>（char也是一种整型，所以可以按%d输出，但不能直接以%d形式输入。）</p>
<h3 id="1-2字符型输入的两种方式"><a href="#1-2字符型输入的两种方式" class="headerlink" title="1.2字符型输入的两种方式"></a>1.2字符型输入的两种方式</h3><p>1.直接以%c配合字符形式输入。</p>
<blockquote>
<p>scanf(“%c”,&amp;c1);</p>
</blockquote>
<p>此时输入’1’,即可将’1’赋给c1。</p>
<blockquote>
<p>printf(“‘%c’”,c1);</p>
</blockquote>
<p>得到1。</p>
<p>2.先用%d给另一个整型变量i输入，再将该i值赋给字符s1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;i);</span><br><span class="line">s1&#x3D;i;</span><br><span class="line">printf(&quot;&#39;%c&#39;&quot;,s1);</span><br></pre></td></tr></table></figure>
<p>此时如果给i输入49，则i将49传给s1，若按%c输出s1就是’1’，若按%d输出则为49.</p>
<h3 id="1-3混合输入输出"><a href="#1-3混合输入输出" class="headerlink" title="1.3混合输入输出"></a>1.3混合输入输出</h3><blockquote>
<p>scanf(“%d %c”,&amp;i,&amp;s1);</p>
</blockquote>
<blockquote>
<p>scanf(“%d%c”,&amp;i,&amp;s1);</p>
</blockquote>
<p>由于第一个函数%d与%c之间有空格，那么输完一个整型数字后的所有空格,tab,return都会被读掉，然后再去读s1.</p>
<p>而第二个函数%d%c之间没空格，所以整数就只读到整数结束为止，下面的东西读给s1,无论是空格，tab还是return都会给到c.</p>
<h3 id="1-4字符运算"><a href="#1-4字符运算" class="headerlink" title="1.4字符运算"></a>1.4字符运算</h3><p>注意两个式子：</p>
<blockquote>
<p>char a =’A;</p>
</blockquote>
<blockquote>
<p>a++;</p>
</blockquote>
<p>则a=’B’</p>
<p>如果要求两个字母间的距离，要用int</p>
<blockquote>
<p>int i= ‘a’-‘A;</p>
</blockquote>
<blockquote>
<p>printf(“%d”,i)=25</p>
</blockquote>
<p>用a+’a’-‘A’从大写变小写<br>用a+’A’-‘a’从小写变大写<br>注意第一个a是整数，不是字符，这里想表达一种变化性，当然也可以写成某一个特定字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> d;</span><br><span class="line">    c=<span class="string">&#x27;d&#x27;</span>+<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//注意是字符d，</span></span><br><span class="line">    d=c+<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>;<span class="comment">//注意是变量c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%c d=%c&quot;</span>,c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<blockquote>
<p>c=D d=d</p>
</blockquote>
<h2 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h2><h3 id="2-1字符数组与字符串——数组方式初始化字符串"><a href="#2-1字符数组与字符串——数组方式初始化字符串" class="headerlink" title="2.1字符数组与字符串——数组方式初始化字符串"></a>2.1字符数组与字符串——数组方式初始化字符串</h3><p>字符串也是字符数组，不过它的结尾是数字0（多表示成’\0’）。</p>
<p>正常的字符数组初始化：</p>
<blockquote>
<p>char s[]={‘H’,’E’,’L’,’L’,’O’,’!’};</p>
</blockquote>
<p>字符串数组的初始化：</p>
<blockquote>
<p>char s[]={‘H’,’E’,’L’,’L’,’O’,’!’,’\0’};</p>
</blockquote>
<p>就是因为结尾的0，才让这个字符数组变成了C语言的字符串。</p>
<h3 id="2-2字符串的存在形式"><a href="#2-2字符串的存在形式" class="headerlink" title="2.2字符串的存在形式"></a>2.2字符串的存在形式</h3><p>字符串以数组的形式存在，可以通过数组或指针的方式进行访问。</p>
<p>！！指针方式：</p>
<blockquote>
<p>char *str=”Hello”;</p>
</blockquote>
<p>注意这表示str是一个指针，指向的内容是字符类型的，只不过现在这个情况下它指的是个字符数组，所以它是字符串，他也完全可以指向一个单个字符，那就不是字符串了！</p>
<p>数组方式：除了上述的依次枚举表达方式，还有如下：</p>
<blockquote>
<p>char word[]=”Hello”;</p>
</blockquote>
<blockquote>
<p>char line[10]=”Hello”;</p>
</blockquote>
<p>注意双引号。</p>
<p>此外，紧密相邻的字符串会被连接起来：</p>
<blockquote>
<p>printf(“A”</p>
</blockquote>
<blockquote>
<p>“B”);</p>
</blockquote>
<p>最终会输出AB.</p>
<h3 id="2-3字符串在内存中的存储方式"><a href="#2-3字符串在内存中的存储方式" class="headerlink" title="2.3字符串在内存中的存储方式"></a>2.3字符串在内存中的存储方式</h3><p>以数组方式表达的字符串，其地址存在于计算机的代码段，是只读的，所以无法对数组表达的字符串进行修改。</p>
<p>同时，存储相同字符串的不同变量，他们的地址相同，相当于一人分饰两角。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s=<span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *s1=<span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s=%p s1=%p&quot;</span>,s,s1); <span class="comment">//会发现s==s1;</span></span><br><span class="line">s[<span class="number">0</span>]=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>这样的程序是会报错的。换句话说：</p>
<p>char *s == const char *s 即指针所指向的char类型内容（即字符串）是const型的。</p>
<h3 id="2-4字符串的输入输出"><a href="#2-4字符串的输入输出" class="headerlink" title="2.4字符串的输入输出"></a>2.4字符串的输入输出</h3><p>常见的方式都是通过数组表达字符串，然后对其进行输入输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
<p>此处注意%s只读入单词，当你输入tab，空格，return都会默认该单词读完了。</p>
<p>为了更安全的输入，会写成%ns，n代表能输入的最大位数，由于本数组大小为8，且最后一位有0，所以最多还能输7位。</p>
<h2 id="三、指针方式的输入输出"><a href="#三、指针方式的输入输出" class="headerlink" title="三、指针方式的输入输出"></a>三、指针方式的输入输出</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s=<span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *s1=<span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s&quot;</span>,s,s1);</span><br></pre></td></tr></table></figure>
<p>我发现都可以输出Hello,World!.<br>这让我很疑惑，因为s和s1不是存放的地址吗，而想输出*s,*s1却也可以通过编译，但是无法输出内容。</p>
<p>我尝试了：</p>
<blockquote>
<p>printf(“%c %d”,*s,*s);</p>
</blockquote>
<p>输出得到了’H’ 72 (‘H’的ASCII码)</p>
<p>所以关于<strong>指针和数组</strong>之间的关系，我必须再看看C primer plus.</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据预处理</title>
    <url>/2020/09/08/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>本文基于kaggle上的房价预测项目，对数据预处理的流程进行总结。由于这是上手的第一个项目，数据预处理的过程相对比较简单，主要涵盖了数据感知可视化，outliers的清理，空值填充，及初步选取特征四个方面，后续会不断加入categorical encoding，添加特征等方法。</p>
<a id="more"></a>

<h2 id="1-关于题目"><a href="#1-关于题目" class="headerlink" title="1.关于题目"></a>1.关于题目</h2><p>题目链接：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques%E3%80%82">https://www.kaggle.com/c/house-prices-advanced-regression-techniques。</a></p>
<p>题目解读：围绕79个特征对Ames市的房价进行预测，其中44个特征是离散型的分类，35个特征是连续型的数值。</p>
<p>本文策略：在填充空值时，优先将筛选出的特征中的空值进行填充，而不是将所有特征中的空值填充，这样做的好处是比较简单，但同时注定无法构造一个底子很好的baseline。</p>
<h2 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2.数据预处理"></a>2.数据预处理</h2><h3 id="1-导入必要包及数据"><a href="#1-导入必要包及数据" class="headerlink" title="1.导入必要包及数据"></a>1.导入必要包及数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment">#matplotlit infine</span></span><br><span class="line"></span><br><span class="line">train_data = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-对数据进行初步探索"><a href="#2-对数据进行初步探索" class="headerlink" title="2.对数据进行初步探索"></a>2.对数据进行初步探索</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 探索数据维度,是否有空值等信息</span></span><br><span class="line">train_data.info()</span><br></pre></td></tr></table></figure>

<p>从这步可以看出来，Alley、FireplaceQu、PoolQC、Fence等特征存在较多的空值；同时有很多特征具有很强的相关性，比如GarageCars与GarageArea，1stFlrSF，2ndFlrSF 与GrLivArea等。这些可以留作后面优化baseline的策略；此外，观察了数据，发现有些空值存在的原因是因为一些房子本身就没有该配套设施所导致的，比如Garagetype为空的原因是该房子根本没有garage。</p>
<h3 id="3-观察特征X与SalePrice之间的相关性"><a href="#3-观察特征X与SalePrice之间的相关性" class="headerlink" title="3.观察特征X与SalePrice之间的相关性"></a>3.观察特征X与SalePrice之间的相关性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用pandas自带的关联矩阵，可以观察到变量与结果之间的相关性，并以热力图的方式呈现。</span></span><br><span class="line">corr = train_data.corr() <span class="comment">#生成相关性矩阵，默认的method是&#x27;pearson&#x27;，即皮尔森相关系数。</span></span><br><span class="line">fig = plt.figure(figsize =(<span class="number">10</span>,<span class="number">10</span>)) <span class="comment"># 构造画布</span></span><br><span class="line">sns.heatmap(data = corr, vmin= <span class="number">0.2</span>，cmap=<span class="string">&#x27;YlGnBu&#x27;</span>,square = <span class="literal">True</span>) <span class="comment">#过滤相关性在0.2以下的值,颜色采用蓝色系，以方形图表示。</span></span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1giljdrakaaj31180vctfc.jpg" alt="1.png"></p>
<p>由此可以看到SalePrice一项与特征中的’OverallQual’，’GrLivArea’，’TotalBsmtSF’，’GarageCars’四项的相关性比较大（热力图中颜色较深），故想单独把这4个特征提取出来，看看他们与SalePrice是否真的呈现某种线性关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 围绕四个相关性大的特征进行观察其与SalePrice的线性关系</span></span><br><span class="line">cols = [<span class="string">&#x27;OverallQual&#x27;</span>,<span class="string">&#x27;GrLivArea&#x27;</span>,<span class="string">&#x27;TotalBsmtSF&#x27;</span>,<span class="string">&#x27;GarageCars&#x27;</span>]</span><br><span class="line">fig = plt.figure()</span><br><span class="line">sns.pairplot(x_vars=cols, y_vars=<span class="string">&#x27;SalePrice&#x27;</span>, data=train_data)</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1gilje597yij315w0e0tbu.jpg" alt="2.png"></p>
<h3 id="3-针对outliers分析"><a href="#3-针对outliers分析" class="headerlink" title="3.针对outliers分析"></a>3.针对outliers分析</h3><p>通过图形可以发现，上述四个特征确实与SalePrice有较为明显的线性关系，但其中也有一些outliers，为了不影响模型的拟合，将这些outliers分析一下，如果确实比较离谱则将其丢弃。</p>
<h4 id="针对OverallCond："><a href="#针对OverallCond：" class="headerlink" title="针对OverallCond："></a>针对OverallCond：</h4><p>这个是我后面发现的，有一个OverallCond=2的样本点的售价远高于其他样本点，故将其drop掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.drop(index = train_data[(train_data[<span class="string">&#x27;OverallCond&#x27;</span>]==<span class="number">2</span>) &amp; (train_data[<span class="string">&#x27;SalePrice&#x27;</span>]&gt;<span class="number">200000</span>)].index,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="针对GrLivArea："><a href="#针对GrLivArea：" class="headerlink" title="针对GrLivArea："></a>针对GrLivArea：</h4><p>有两个点的非常靠右，但是售价非常低，大致估计其原因应该是地处偏僻，故直接删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.drop(index = train_data[(train_data[<span class="string">&#x27;GrLivArea&#x27;</span>]&gt;<span class="number">4000</span>) &amp; (train_data[<span class="string">&#x27;SalePrice&#x27;</span>]&lt;<span class="number">200000</span>)].index,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="针对TotalBsmtSF"><a href="#针对TotalBsmtSF" class="headerlink" title="针对TotalBsmtSF:"></a>针对TotalBsmtSF:</h4><p>同样有一个点的地下室面积非常大，但是售价很低，故将其drop。另外大于2500房价却小与200000数据点需要找出来单独分析一下原因，观察是不是outliers。(这里没找，没找到，略过了)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先drop离谱点，事实证明这就是刚刚drop掉那两个样本点中的一个</span></span><br><span class="line">train_data.drop(index = train_data[train_data[<span class="string">&#x27;TotalBsmtSF&#x27;</span>]&gt;<span class="number">6000</span>].index,inplace=<span class="literal">True</span>) </span><br></pre></td></tr></table></figure>

<h4 id="针对GarageCars"><a href="#针对GarageCars" class="headerlink" title="针对GarageCars:"></a>针对GarageCars:</h4><p>针对GarageCars我重新做了箱线图，发现可以容纳4个车位的Garage平均售价远低于可以容纳3个车位的房子，我不知道是不是应该将他们drop点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 围绕GarageCars做的箱线图</span></span><br><span class="line">sns.boxplot(x=<span class="string">&#x27;GarageCars&#x27;</span>,y=<span class="string">&#x27;SalePrice&#x27;</span>,data=train_data)</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1giljh0g8fkj30qq0fkmy4.jpg" alt="3.png"></p>
<p>将所有GarageCars=4的数据提取出来进行观察。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.loc[index_of_4cars,:][[<span class="string">&#x27;SalePrice&#x27;</span>,<span class="string">&#x27;GarageArea&#x27;</span>,<span class="string">&#x27;GarageFinish&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1giljm41z7gj30h409wt91.jpg" alt="4.png"></p>
<p>另外求一下不同GarageCars的房子的平均GarageArea。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data[<span class="string">&#x27;GarageArea&#x27;</span>].groupby(train_data[<span class="string">&#x27;GarageCars&#x27;</span>]).mean()</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1giljqay95kj30eo06oq36.jpg" alt="5.png"></p>
<p>可以发现1340号房屋的GarageCars虽然是4，但是其GarageArea非常小，同时它的车库还是未完工的状态（Unf），所以1340号房屋的售价较低是可以解释的。不过1190号房屋的车库面积非常大，同时是完工状态，不过其售价非常低，有悖于刚刚的结论，所以考虑将其删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除1190号房屋</span></span><br><span class="line">train_data.drop(index=<span class="number">1190</span>,inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>目前已经针对几个主要属性，将部分outliers进行过滤，下面将训练集的index进行重置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data.reset_index(inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-围绕Garage属性进行特征筛选"><a href="#4-围绕Garage属性进行特征筛选" class="headerlink" title="4.围绕Garage属性进行特征筛选"></a>4.围绕Garage属性进行特征筛选</h3><p>由于数据集中经常出现GarageCars很大但GarageArea小的情况，比如一个可以容纳4个车的车库只有480平，反之，样本中也可能出现只容纳1个车但车库面积非常大的现象。所以我打算用GarageArea除以GarageCars，观察每个车位的平均Area，看该特征下SalePrice的线性是否明显。    </p>
<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1gillwztz7wj30cc0bagmh.jpg" alt="6.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个新的字段</span></span><br><span class="line">train_data[<span class="string">&#x27;Avg_Garage&#x27;</span>] = train_data[<span class="string">&#x27;GarageArea&#x27;</span>]/(train_data[<span class="string">&#x27;GarageCars&#x27;</span>]+<span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># 观察以Avg_Garage为自变量的SalePrice变化。</span></span><br><span class="line">sns.pairplot[x_vars=<span class="string">&#x27;Avg_Garage&#x27;</span>,y_vars=<span class="string">&#x27;SalePrice&#x27;</span>,data=train_data]</span><br></pre></td></tr></table></figure>

<p>依然没看出来有线性关系，当Avg_Garage变大时，部分房子的售价非常的低，所以不打算就这个Avg_Garage再深入了。另外我观察了GarageArea的散点图，发现它的线性关系更加明显，所以最终二选一的话我会选Area而不是Cars。<img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1gillwlgw03j30c40ast9s.jpg" alt="8.png"></p>
<p>接下来我围绕GarageCars和GarageFinish进行groupby，观察到在每个档次的GarageCars里，Fin&gt;Rfn&gt;Ufn。所以我想把GarageFinish也当作一个影响总价的重要特征，纳入考虑。</p>
<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1gillx805c9j30iu0cwt9l.jpg" alt="7.png"></p>
<p>综上，围绕Garage我将选择GarageArea及GarageFinish作为两个主要特征。</p>
<h3 id="5-利用pearson相关系数找到与SalePrice最相关的几个属性。"><a href="#5-利用pearson相关系数找到与SalePrice最相关的几个属性。" class="headerlink" title="5.利用pearson相关系数找到与SalePrice最相关的几个属性。"></a>5.利用pearson相关系数找到与SalePrice最相关的几个属性。</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr = train_data.corr() <span class="comment"># 相关性矩阵（dataframe）</span></span><br><span class="line">k = <span class="number">10</span></span><br><span class="line">cols = corr.nlargest(k,<span class="string">&#x27;SalePrice&#x27;</span>).index <span class="comment">#按&#x27;SalePrice&#x27;排列的前k行，并返回它们的index</span></span><br><span class="line">cm = np.corrcoef(train_data[cols].values.T) <span class="comment"># 计算pearson相关系数，接受的参数是一个矩阵，返回的也是一个矩阵，</span></span><br><span class="line">sns.<span class="built_in">set</span>(font_scale=<span class="number">0.8</span>)</span><br><span class="line">heatmap = sns.heatmap(cm,annot=<span class="literal">True</span>,yticklabels=cols.values,xticklabels=cols.values,cmap=<span class="string">&#x27;YlGnBu&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://ww1.sinaimg.cn/mw690/0060e3lIly1gillxfyxodj30ne0gwjwa.jpg" alt="9.png"></p>
<p>综上，我将选择OverallQual,GrLivArea,TotalBsmtSF,GarageArea,GarageFinish,</p>
<p>1stFirSF,FullBath,TotRmsAbvGrd,YearBuilt作为最终特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cols = [<span class="string">&#x27;OverallQual&#x27;</span>,<span class="string">&#x27;GrLivArea&#x27;</span>, <span class="string">&#x27;GarageArea&#x27;</span>,<span class="string">&#x27;GarageFinish&#x27;</span>,<span class="string">&#x27;TotalBsmtSF&#x27;</span>, <span class="string">&#x27;FullBath&#x27;</span>, <span class="string">&#x27;1stFirSF&#x27;</span>,<span class="string">&#x27;TotRmsAbvGrd&#x27;</span>,<span class="string">&#x27;YearBuilt&#x27;</span>]</span><br><span class="line"><span class="comment"># 将GarageFinish进行Categorical编码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cols = [<span class="string">&#x27;OverallQual&#x27;</span>,<span class="string">&#x27;GrLivArea&#x27;</span>, <span class="string">&#x27;GarageArea&#x27;</span>,<span class="string">&#x27;GarageFinish&#x27;</span>,<span class="string">&#x27;TotalBsmtSF&#x27;</span>, <span class="string">&#x27;FullBath&#x27;</span>, <span class="string">&#x27;1stFirSF&#x27;</span>,<span class="string">&#x27;TotRmsAbvGrd&#x27;</span>,<span class="string">&#x27;YearBuilt&#x27;</span>]</span><br><span class="line">x = train_data[cols].values</span><br><span class="line">y = train_data[<span class="string">&#x27;SalePrice&#x27;</span>].values</span><br><span class="line">x_scaled = preprocessing.StandardScaler().fit_transform(x)</span><br><span class="line">y_scaled = preprocessing.StandardScaler().fit_transform(y.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">X_train,X_test, y_train, y_test = train_test_split(x_scaled, y_scaled, test_size=<span class="number">0.33</span>, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>SKlearn</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2020/10/27/%E6%B6%88%E9%99%A4%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>本文记录了使用SKlearn进行机器学习过程中遇到的一些问题，包括数据可视化及数据预处理。</p>
<a id="more"></a>

<h2 id="1-消除警告信息"><a href="#1-消除警告信息" class="headerlink" title="1.消除警告信息"></a>1.消除警告信息</h2><p>python开发中经常遇到报错的情况，但是warning通常并不影响程序的运行，而且有时特别讨厌，该语句主要用来忽略warning错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-更改图标显示风格，非必要"><a href="#2-更改图标显示风格，非必要" class="headerlink" title="2.更改图标显示风格，非必要"></a>2.更改图标显示风格，非必要</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-sklearn的转换器和分类器"><a href="#3-sklearn的转换器和分类器" class="headerlink" title="3.sklearn的转换器和分类器"></a>3.<strong>sklearn的转换器和分类器</strong></h2><h3 id="1-BaseEstimator"><a href="#1-BaseEstimator" class="headerlink" title="(1)BaseEstimator:"></a>(1)BaseEstimator:</h3><p>基础分类器的类（Base class for all estimators in scikit-learn）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InductiveClusterer</span>(<span class="params">BaseEstimator</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, clusterer, classifier</span>):</span></span><br><span class="line">        self.clusterer = clusterer</span><br><span class="line">        self.classifier = classifier</span><br><span class="line"><span class="comment">#这里表示新建一个派生类InductiveClusterer,它继承了基类BaseEstimator</span></span><br></pre></td></tr></table></figure>

<p><strong>名称 BaseClassName 必须定义于包含派生类定义的作用域中</strong>。也允许用其他任意表达式代替基类名称所在的位置。 这有时也可能会用得上，例如，当基类定义在另一个模块中的时候:</p>
<p><strong>class DerivedClassName(modname.BaseClassName):</strong></p>
<h3 id="2-其他分类器和转换器"><a href="#2-其他分类器和转换器" class="headerlink" title="(2)其他分类器和转换器"></a>(2)其他分类器和转换器</h3><p>ClassifierMixin是基础转换器, RegressorMixin基础回归器,TransformerMixin是基础转换器。</p>
<p>RegressorMixin和ClassifierMixin里只有Score方法，没有fit方法，需要自己写到mixin里去实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator, TransformerMixin, RegressorMixin, clone</span><br></pre></td></tr></table></figure>

<h2 id="4-RobustScaler与StandardScaler的区别"><a href="#4-RobustScaler与StandardScaler的区别" class="headerlink" title="4.RobustScaler与StandardScaler的区别"></a>4.RobustScaler与StandardScaler的区别</h2><p>StandardScaler可以将数据中心化，具体的操作是将数据减去均值后除以标准差。</p>
<p>而对于有离群点，尤其是outliers比较多的情况，使用均值和标准差方式标准化效果不好，这种时候考虑用RobustScaler。具体的方法是移除中位数并根据IQR范围对数据缩放（IQR:在1分位数和3分位数之间）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> RobustScaler, StandardScaler</span><br></pre></td></tr></table></figure>

<h2 id="5-引入均方误差"><a href="#5-引入均方误差" class="headerlink" title="5.引入均方误差"></a>5.引入均方误差</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line">y_true = [<span class="number">3.0</span>, <span class="number">-0.5</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br><span class="line">y_pred = [<span class="number">2.5</span>,  <span class="number">0.0</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">mean_squred_error(y_true,y_min) <span class="comment">#0.375</span></span><br><span class="line">mean_squred_error(y_true,y_min,squared=<span class="literal">False</span>) <span class="comment">#0.612</span></span><br><span class="line"><span class="comment">#squred: If True returns MSE value, if False returns RMSE value.</span></span><br></pre></td></tr></table></figure>

<h2 id="6-pipeline和make-pipeline"><a href="#6-pipeline和make-pipeline" class="headerlink" title="6.pipeline和make_pipeline"></a>6.pipeline和make_pipeline</h2><p>pipeline是你给steps命名，而make_pipeline是根据方法自动命名steps。</p>
<p>The only difference is that <code>make_pipeline</code> generates names for steps automatically.</p>
<p>Step names are needed e.g. if you want to use a pipeline with model selection utilities (e.g. GridSearchCV). With grid search you need to specify parameters for various steps of a pipeline:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pipe = Pipeline([(<span class="string">&#x27;vec&#x27;</span>, CountVectorizer()), (<span class="string">&#x27;clf&#x27;</span>, LogisticRegression()])</span><br><span class="line">param_grid = [&#123;<span class="string">&#x27;clf__C&#x27;</span>: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>]&#125;</span><br><span class="line">gs = GridSearchCV(pipe, param_grid)</span><br><span class="line">gs.fit(X, y)</span><br></pre></td></tr></table></figure>

<p>compare it with make_pipeline:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pipe = make_pipeline(CountVectorizer(), LogisticRegression())     </span><br><span class="line">param_grid = [&#123;<span class="string">&#x27;logisticregression__C&#x27;</span>: [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>]&#125;</span><br><span class="line">gs = GridSearchCV(pipe, param_grid)</span><br><span class="line">gs.fit(X, y)</span><br></pre></td></tr></table></figure>

<p>So, with <code>Pipeline</code>:</p>
<ul>
<li>names are explicit, you don’t have to figure them out if you need them;</li>
<li><strong>name doesn’t change if you change estimator/transformer used in a step, e.g. if you replace LogisticRegression() with LinearSVC() you can still use <code>clf__C</code>.</strong></li>
</ul>
<p><code>make_pipeline</code>:</p>
<ul>
<li>shorter and arguably more readable notation;</li>
<li>names are auto-generated using a straightforward rule (lowercase name of an estimator).</li>
</ul>
<p>When to use them is up to you :) I prefer make_pipeline for quick experiments and Pipeline for more stable code; a rule of thumb: IPython Notebook -&gt; make_pipeline; Python module in a larger project -&gt; Pipeline. But it is certainly not a big deal to use make_pipeline in a module or Pipeline in a short script or a notebook.</p>
<h3 id="7-克隆estimator"><a href="#7-克隆estimator" class="headerlink" title="7.克隆estimator"></a>7.克隆estimator</h3><p>Constructs a new estimator with the same parameters.</p>
<p>Clone does a deep copy of the model in an estimator without actually copying attached data. It yields a new estimator with the same parameters that has not been fit on any data.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sklearn.base.clone(estimator, *, safe=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="8-sklearn-impute-SimpleImputer"><a href="#8-sklearn-impute-SimpleImputer" class="headerlink" title="8.sklearn.impute.SimpleImputer"></a>8.sklearn.impute.SimpleImputer</h3><p>用来填补缺失值（missing_valules），采取strategy策略，注意strategy一般都应用在各列（column）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">impute</span>.<span class="title">SimpleImputer</span>(<span class="params">*, missing_values=nan, strategy=<span class="string">&#x27;mean&#x27;</span>, fill_value=<span class="literal">None</span>, verbose=<span class="number">0</span>, copy=<span class="literal">True</span>, add_indicator=<span class="literal">False</span></span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp_mean = SimpleImputer(missing_values=np.nan, strategy=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>imp_mean.fit([[<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, np.nan, <span class="number">3</span>], [<span class="number">10</span>, <span class="number">3</span>, np.nan]])</span><br><span class="line">SimpleImputer()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[np.nan, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, np.nan, <span class="number">5</span>], [<span class="number">1</span>,<span class="number">4</span>,np.nan]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(imp_mean.transform(X))</span><br><span class="line">array([[<span class="number">6.33333333</span>, <span class="number">2.</span>        , <span class="number">3.</span>        ],</span><br><span class="line">       [<span class="number">2.</span>        , <span class="number">2.5</span>       , <span class="number">5.</span>        ],</span><br><span class="line">       [<span class="number">1.</span>        , <span class="number">4.</span>        , <span class="number">3.</span>        ]])</span><br><span class="line"><span class="comment">#注意是拿第一个数组fit后的参数去填充第二个数组的missing_values.</span></span><br></pre></td></tr></table></figure>

<h3 id="9-scipy-stats库"><a href="#9-scipy-stats库" class="headerlink" title="9.scipy_stats库"></a>9.scipy_stats库</h3><p>主要包含了一些统计学上的特征值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> skew</span><br></pre></td></tr></table></figure>

<h3 id="10-pandas中的transform和apply函数"><a href="#10-pandas中的transform和apply函数" class="headerlink" title="10.pandas中的transform和apply函数"></a>10.pandas中的transform和apply函数</h3><p><a href="https://zhuanlan.zhihu.com/p/86350553">https://zhuanlan.zhihu.com/p/86350553</a></p>
<h3 id="11-map函数"><a href="#11-map函数" class="headerlink" title="11.map函数"></a>11.map函数</h3><p>注意DataFrame和Series的map函数和python内置的有些不同。</p>
<h3 id="12-select-dtypes函数"><a href="#12-select-dtypes函数" class="headerlink" title="12.select_dtypes函数"></a>12.select_dtypes函数</h3><p>一个dataframe中可能有多种类型的数据，select_dtypes用于选择某种特定类型的数据。</p>
<p>include:包含该类型的都要，exclude:除了该类型的都要。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataFrame.select_dtypes(include = <span class="literal">None</span>, exclude = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>罗格斯特征数</title>
    <url>/2020/10/27/%E7%BD%97%E6%A0%BC%E6%96%AF%E7%89%B9%E5%BE%81%E6%95%B0/</url>
    <content><![CDATA[<p>现第一行有0 1 2 3 4 5 6 7 8 9这10个数字。</p>
<p>在第二行这10个数字下方以如下方法填入新的数字：每个位置填入的数字是上方对应的数字将要在第二行出现的次数。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>思路： 判断哪个数字应该出现的次数最多</p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>概率趣味题</tag>
      </tags>
  </entry>
  <entry>
    <title>赛马问题</title>
    <url>/2020/11/07/%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>有64匹马，一共有8个赛道，想要找出最快的4匹马，要比赛最少多少轮才可以？</p>
<a id="more"></a>

<p>要点：</p>
<ol>
<li>注意只是选出最快的4匹，并不用对他们进行排序。</li>
<li>时刻记住只要某匹马前面有4匹比它快，他就要淘汰。</li>
</ol>
<p>答案：最快的情况需要10轮，极端情况需要11轮。</p>
<p>首先将64匹马分成8组，进行8轮比赛。在这8组比赛中，淘汰每轮比赛的后四名—剩32匹马。（8轮）</p>
<p>然后将8个组的第一名一起赛一下，只保留前4名所属的组—剩16匹马。（1轮）</p>
<p>剩下的如图所示：</p>
<table>
<thead>
<tr>
<th align="center">A1</th>
<th align="center">A2</th>
<th align="center">A3</th>
<th align="center">A4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B1</td>
<td align="center">B2</td>
<td align="center">B3</td>
<td align="center">B4</td>
</tr>
<tr>
<td align="center">C1</td>
<td align="center">C2</td>
<td align="center">C3</td>
<td align="center">C4</td>
</tr>
<tr>
<td align="center">D1</td>
<td align="center">D2</td>
<td align="center">D3</td>
<td align="center">D4</td>
</tr>
</tbody></table>
<p>当前已知的排序是：</p>
<p>A1&gt;B1&gt;C1&gt;D1</p>
<p>A1&gt;A2&gt;A3&gt;A4</p>
<p>B1&gt;B2&gt;B3&gt;B4</p>
<p>C1&gt;C2&gt;C3&gt;C4</p>
<p>D1&gt;D2&gt;D3&gt;D4</p>
<p>如果某匹马前面有4只比它快，它就要淘汰，所以D2,D3,D4,C3,C4,B4注定要淘汰，只剩下左半区的，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">A1</th>
<th align="center">A2</th>
<th align="center">A3</th>
<th align="center">A4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B1</td>
<td align="center">B2</td>
<td align="center">B3</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">C1</td>
<td align="center">C2</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">D1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>并且可以知道当前A1是最快的，所以问题变成了从剩余9匹马中选3匹最快的<strong>（你无需知道这三匹谁更快，找出来即可）</strong></p>
<p>由此看来，2步内必然能够完成，但是有没有一些情况可以一步到位?</p>
<p>假设B1是前4中的一员，现在看一下剩下8匹马中最快的。分为以下3中情况：</p>
<ol>
<li><p>如果最快的马是B2或C1,那证明A组剩下的都必然没B1快，所以这8匹马中的前两名以及A1,B1就是最后的4匹马。</p>
</li>
<li><p>如果8匹中最快是A2，那看8匹中的第二快。如果是B2或者C1的话，依然可以做出判断，最后的马是A1,A2,B1以及B2/C1之一。</p>
</li>
<li><p>如果8匹马中最快的是A2，第二是A3，就看第三名。如果第三名不是A4，那结束判断，最后的马是A1,A2,A3,B1。（因为A4都没跑过B2或C1中的那个，更不会跑过B1）</p>
</li>
<li><p>如果8匹马中最快的是A2,A3,A4，很不幸，再加一轮比较以下B1和A4吧。</p>
</li>
</ol>
<p>前三种情况下都只需要1轮，就能下决断，只有第四种情况需要为判断B1和A4而多加1轮。</p>
<p>综上所述，10轮或11轮都有可能。</p>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>概率趣味题</tag>
      </tags>
  </entry>
</search>
